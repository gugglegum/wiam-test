# Обработчик кредитных заявок (тестовое задание для Wiam Group)

Приложение обрабатывает заявки пользователей на кредит, обеспечивая целостность данных и предотвращая условия гонки с помощью механизмов блокировки в базе данных PostgreSQL. Проект предоставляет API из 2 методов: `POST /requests` и `GET /processor?delay=5`. Первый позволяет создавать новые заявки на кредит от пользователей, а второй запускает обработку всех необработанных заявок. Обработка заявок сводится к изменению статуса на Одобрено или Отказано. Решение принимается случайным образом с вероятностью 10% в пользу одобрения. При этом, если у пользователя уже есть хотя бы одна одобренная заявка, то все новые заявки должны получать отказ.

По условию задачи возможен одновременный запуск нескольких процессов обработки заявок, что не должно мешать корректному выполнению и сохранению базовых условий: не более одной одобренной заявки на пользователя. При этом в обработке заявки добавлена эмуляция задержки, длительность которой в секундах передаётся в GET-параметре delay.

Из-за параллельного выполнения теоретически возможна ситуация, когда оба процесса получили разные заявки, но от одного пользователя, одновременно проверили наличие у него одобренных заявок, одновременно убедились, что таких заявок нет, и одновременно оба одобрили каждый свою заявку. В этом случае нарушается условие задачи про только одну одобренную заявку на пользователя. Для удобства тестирования данного аспекта задержка вставлена именно между проверкой одобренных заявок и обновлением статуса. Для решения этой проблемы было решено использовать блокировку строки пользователя текущей обрабатываемой заявки через `SELECT ... FOR UPDATE NOWAIT`. `FOR UPDATE` блокирует строку до завершения транзакции и не позволяет другому процессу получить блокировку этой же записи. А `NOWAIT` позволяет не блокировать выполнение другого процесса, который наткнулся на заблокированного пользователя, а сразу пропустить заявку и перейти к следующей. Таким образом несколько процессов обработки работают параллельно, их производительность кратна кол-ву запущенных процессов и не возникает конфликтов. Также на всякий случай обрабатывается вероятность Deadlock и Serialization failure - в этом случае производится повторное выполнение транзакции с той же заявкой.

В задании также указано, что заявки одного пользователя могут обрабатываться одновременно. Но я не совсем понял имеется ли в виду, что в параллельных процессах в принципе могут попасться заявки одного пользователя, или требуется именно, чтобы 2 процесса одновременно могли обрабатывать 2 заявки одного пользователя в активном режиме. Если второй вариант, то тут требуется другой подход: необходимо перенести блокировку строки пользователя на момент перед проверкой наличия одобренных заявок и без `NOWAIT`, а эмуляцию задержки перенести куда-нибудь до этого момента. Тогда при одновременной обработке заявок одного пользователя и одновременной проверке наличия у него одобренных заявок, один из процессов будет блокироваться на короткое время (всего 2 лёгких запроса: `SELECT` и `UPDATE`) и продолжаться когда другой процесс уже установил новый статус заявки и закоммитил его. Если необходимо, я могу переделать на такой вариант. Но мой вариант по идее чуточку быстрее, т.к. в нём вообще нет ожидания освобождения блокировки. 

На выполнение задания было потрачено около 7 часов, т.к. у меня не хватало опыта с PostgreSQL, Docker, плюс с Yii 2 я последний раз работал много лет назад, были некоторые трудности с ActiveQuery, с логированием. Ну и в целом надо было продумать как лучше организовать параллельную обработку.

## Что нового в версии 1.0.1

Проведён рефакторинг кода, в ходе которого:

* Вся бизнес-логика вынесена в отдельные сервисные классы, контроллеры сделаны "тонкими".
* Добавлены интерфейсы для сервисных классов и конкретная реализация теперь задаётся через DI-контейнер.
* Удалён лишний уровень транзакции.
* Добавлена консольная команда `php yii processor 5` (аналог `GET /processor?delay=5`), которая делает всё то же самое, но за счёт отображения лога в консоли в реальном времени удобнее наблюдать за происходящим в двух одновременно запущенных терминалах.
* Улучшена обработка ошибок. Добавлена случайная задержка между повторами транзакций при обнаружении deadlock. Добавлено ограничение на максимальное кол-во повторов.
* Добавлены Swagger-аннотации для автоматической генерации документации API.

## Установка

(предполагается, что вы используете Debian/Ubuntu-подобный Linux)

Клонируем репозиторий и запускаем докер-контейнеры:

```bash
git clone https://github.com/gugglegum/wiam-test.git
cd wiam-test
sudo docker-compose up -d
```

Заходим внутрь php-контейнера и производим в нём первичную настройку:

```bash
sudo docker exec -it php-container bash
curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
apt install git
apt install unzip
composer install
php yii migrate
php yii user/create "john_doe" "john.doe@example.com" "secure_password123"
php yii user/create "john_smith" "john.smith@example.com" "secure_password321"
php yii user/create "jane_public" "jane.public@example.com" "secure_password312"
chmod -R 777 runtime
```

Так мы установили внутри php-контейнера Composer, git, unzip (нужен для composer), выполнили `composer install`, накатили миграции и создали 3 тестовых пользователя.

Далее выходим из докер-контейнера и через HTTP-запросы добавляем несколько тестовых заявок на кредиты:

```bash
curl -X POST -H "Content-Type: application/json" -d '{"user_id": 1, "amount": 3000, "term": 30}' http://localhost:8080/request
curl -X POST -H "Content-Type: application/json" -d '{"user_id": 2, "amount": 5000, "term": 60}' http://localhost:8080/request
curl -X POST -H "Content-Type: application/json" -d '{"user_id": 1, "amount": 4000, "term": 90}' http://localhost:8080/request
curl -X POST -H "Content-Type: application/json" -d '{"user_id": 2, "amount": 2000, "term": 45}' http://localhost:8080/request
```

### Тестирование

Для проверки текущего состояния заявок можем воспользоваться командой:
```bash
PGPASSWORD=wiam_password psql -U wiam_user -d WiamTest -h localhost -c "SELECT * FROM requests"
```

На начальном этапе у всех заявок должен быть status = 0.

Для проверки одновременного выполнения обработчика заявок открываем 2 терминала и почти одновременно в обоих терминалах запускаем команду:

```bash
curl -X GET "http://localhost:8080/processor?delay=5"
```
После их окончания смотрим лог в runtime/logs/app.log

Для сброса статуса всех заявок можно выполнить:
```bash
PGPASSWORD=wiam_password psql -U wiam_user -d WiamTest -h localhost -c "UPDATE requests SET status = 0"
```

### Как спровоцировать deadlock?

Для этого необходимо создать взаимную блокировку основного процесса скрипта и, например, подключения в терминале через psql. Для начала очистим статус у какой-нибудь заявки. Например, заявки с ID=16 для пользователя с ID=1. Для этого заходим в psql:

```bash
PGPASSWORD=wiam_password psql -U wiam_user -d WiamTest -h localhost
```
и очищаем статус заявки:
```sql
UPDATE requests SET status = 0 WHERE id = 16;
```
Далее запускаем скрипт обработки заявок через веб-запрос или через консольную команду `php yii processor 20` (из контейнера php) и пока длится задержка в psql выполняем:

```sql
BEGIN;
SELECT * FROM requests WHERE id=16 FOR UPDATE;
SELECT * FROM users WHERE id=1 FOR UPDATE;
COMMIT;
```
Когда закончится время задержки в скрипте, произойдёт ошибка "SQLSTATE[40P01]: Deadlock detected", которая приведет к тому, что скрипт повторит попытку обработки этой же заявки после небольшой случайной задержки. Если на второй попытке не будет создана аналогичная конфликтная ситуация, обработка завершится успешно.
